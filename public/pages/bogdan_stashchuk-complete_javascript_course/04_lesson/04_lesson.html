<!----- Header content ----->
<div class="header2__content">
    <!----- HEADER2 WRAPPER-1 ----->
    <div class="header2__wrapper-1">
        <!----- Bread Crumbs ----->
        <div class="header2__bread-crumbs">
            <a href="/" class="back-link main__link-default">Home</a>
            <a href="/basic_of_programming_and_databases" class="back-link main__link-default">Основы
                программирования и баз данных</a>
        </div><!--bread-crumbs-->
    </div><!--header__wrapper-1-->
</div><!--header content -->

<!----- MAIN ----->
<div class="margin__main">
    <div class="main">
        <div class="main__wrapper-1">
            <h1 class="main__title-1">Урок 4: Параллельное программирование. Архитектура. Программное управление.</h1>

            <h class="main__title-3">Программирование в параллельной идеологии</h>

            <p>Программирование в параллельной идеологии представляет собой следующее:</p>

            <p>В момент запуска вашей программы, которая считает сумму чисел от 1 до 1000, вы узнали сколько ядер в
                системе есть. Далее вы раздробили вашу задачу на несколько блоков. Допустим 5 ядер – ок, 1-ое ядро от 1
                до 200, 2-ое ядро от 200 до 400, и так далее, а потом сложить все.
            </p>

            <p>Но основная сложность заключается в следующем – когда вы пишите код под одно ядро, вы всегда знаете, что
                у вас в последовательном исполнении выполняется сначала шаг 1, потом 2, потом 3.
            </p>

            <p>
                Когда вы пишите код под многоядерность, у вас по сути выполняется еще какой-то кусок вашей же программы.
                Сложение от 1 до 500, и сложение от 500 до 1000 выполняются параллельно. Но, чтобы нам получить
                результат, нам нужно дождаться, чтобы и тот посчитал и этот посчитал. Но они не посчитают в один момент
                времени, кто-то посчитает раньше, а кто-то позже. И поэтому их нужно синхронизировать.
            </p>

            <p>
                Сложность еще и в том, что мы люди привыкли мыслить однозадачно. Мы не можем мыслить сразу о нескольких
                вещах.
            </p>

            <p>Поток выполнения программы:</p>

            <p>
                1 поток реагирует на то, что пользователь нажал на экране, 2-ой поток занят тем, что не прерываясь ни на
                что, берет аудио данные на звуковую карту
            </p>



            <h class="main__title-3">Архитектура фон Неймана</h>

            <p>
                Одномерность памяти. Данные + исполняемый код ВМЕСТЕ Адресуемость памяти. Однозначное указание.
                Программное управление. Последовательное исполнение команд.
            </p>



            <h class="main__title-3">Архитектура</h>

            <p>
                Понятие Архитектура, применительно к компьютерам, как правило, содержит в себе некую совокупность
                программного обеспечения и аппаратной начинки. Все современные компьютере на уровне железа устроены по
                схеме архитектуры фон Неймана.
            </p>

            <p>
                ALU – это процессор. Arithmetic logical unit. Арифметическое логическое устройство. Оно обрабатывает все
                данные. Есть устройство ввода – клавиатура, мышка и так далее. Есть устройство вывода – монитор,
                проектор, принтер и т.д. Есть некая память – это то, где наши данные хранятся. Есть устройство, которое
                всем этим управляет - это некий контроллер. Иногда оно встроено во внутренний процессор, иногда оно
                отдельно от процессора.
            </p>

            <p>
                Формально вы должны понимать - есть процессор, память, ввод, вывод.
            </p>

            <p>
                В программировании все делится на 1) Данные и 2) Код, который с этими данными что-то делает.
            </p>

            <p>
                В памяти данной архитектуры можно хранить и данные и программный код, который с этими данными что-то
                делает. Данные хранятся в ячейках. У каждой ячейки есть уникальный номер (адрес).
            </p>

            <p>
                В памяти находятся какие-то команды, например, команда – узнай сколько у тебя ядер. Следующая команда –
                если ядер больше чем одно, тогда перейди на ячейку номер 200, и там уже записано что делать в случае,
                если ядер больше чем одно. Это тот самый выбор, команды исполняются последовательно одна за другой.
            </p>

            <h class="main__title-3">Программное управление</h>
            <p>Есть код и есть данные.</p>
            <p>
                Операционная система и процессор осуществляют арбитраж. OS следит за тем, чтобы все программы, которые
                запущены одновременно не сломали друг друга, чтобы дружили с кучей ядер
            </p>

            <p>
                Функции – это то, что уже написано до нас. Если нам необходимо в программе показать что-то на экране,
                допустим напечатать какое-то число, мы можем потратить время для того, чтобы изучить как это рисуется на
                экране, написать функцию печати, и потом воспользовавшись ее напечатать на экране все что угодно. А
                можем воспользоваться уже готовым, написанным уже кем-то.
            </p>

            <p>
                В функции есть данные на входе и на выходе. Часть функций, с которыми вы будете работать уже написаны.
            </p>



        </div><!--main__wrapper-1-->
    </div><!--main-->
</div><!--margin__main-->